<html>
<head>
<style>
pre {
	display: inline;
	background-color: lightgray;
}
.para {
	height: 0.4em;
}
span {
	outline: 1px solid gray;
	font-style: italic;
	margin: 0 2px;
}
</style>
</head>
<body>
<h2>This Document</h2>
is about the in-game editing. If you read nothing else, read <a href="#buffers">Player Buffers</a>.
Like everything else, this document is not finalized and may contain inaccuracies.
<br/><br/>
This is intended as more of an in-depth technical reference. Consider also the <a href="edit_guide.html">Edit Starter Guide Follow-Along Tutorial Thing</a>, which lets you get started with less reading and more doing. It contains links back to this document. If you're a "more reading" kind of person, you can start here just as well.

<ul id="table_of_contents">
<li><a href="#game_state">Game State</a></li>
<li><a href="#edit_interface">Edit Interface</a>
	<ul>
	<li><a href="#buffers">Player Buffers</a></li>
	<li><a href="#look_dir">Look Direction</a></li>
	</ul>
</li>
<li><a href="#commands">Commands</a>
	<ul>
	<li><a href="#buffer_manip">Buffer Manipulation</a>
		<ul>
		<li><a href="#_inside">/inside</a></li>
		<li><a href="#_wires">/wires</a></li>
		<li><a href="#_held">/held</a></li>
		<li><a href="#_tree">/tree</a></li>
		</ul>
	</li>
	<li><a href="#informational">Informational</a>
		<ul>
		<li><a href="#_i">/i</a></li>
		<li><a href="#_m">/m</a></li>
		<li><a href="#_hl">/hl</a></li>
		</ul>
	</li>
	<li><a href="#material">Material</a>
		<ul>
		<li><a href="#_weight">/weight</a></li>
		<li><a href="#_wall">/wall</a></li>
		<li><a href="#_metal">/metal</a></li>
		<li><a href="#_stone">/stone</a></li>
		<li><a href="#_wood">/wood</a></li>
		<li><a href="#_paper">/paper</a></li>
		<li><a href="#_ghost">/ghost</a></li>
		<li><a href="#_decor">/decor</a></li>
		<li><a href="#_friction">/friction</a></li>
		<li><a href="#_fpdraw">/fpdraw</a></li>
		</ul>
	</li>
	<li><a href="#type">Type</a>
		<ul>
		<li><a href="#_dumb">/dumb</a></li>
		<li><a href="#_logic">/logic</a></li>
		<li><a href="#_logic_debug">/logic_debug</a></li>
		<li><a href="#_rand">/rand</a></li>
		<li><a href="#_delay">/delay</a></li>
		<li><a href="#_demolish">/demolish</a></li>
		<li><a href="#_gun">/gun</a></li>
		<li><a href="#_door">/door</a></li>
		<li><a href="#_teleport">/teleport</a></li>
		<li><a href="#_legg">/legg</a></li>
		<li><a href="#_seat">/seat</a></li>
		<li><a href="#_respawner">/respawner</a></li>
		<li><a href="#_teamselect">/teamselect</a></li>
		<li><a href="#_scoreboard">/scoreboard</a></li>
		<li><a href="#_cursed">/cursed</a></li>
		</ul>
	</li>
	<li><a href="#misc">Miscellaneous</a>
		<ul>
		<li><a href="#_save">/save</a></li>
		<li><a href="#_load">/load</a></li>
		<li><a href="#_loader">/loader</a></li>
		<li><a href="#_file">/file</a></li>
		<li><a href="#_sync">/sync</a></li>
		<li><a href="#_export">/export</a></li>
		<li><a href="#_import">/import</a></li>
		<li><a href="#_add">/add</a></li>
		<li><a href="#_data">/data</a></li>
		<li><a href="#_edit">/edit</a></li>
		<li><a href="#_rule">/rule</a></li>
		<li><a href="#_seed">/seed</a></li>
		<li><a href="#_reseed">/reseed</a></li>
		<li><a href="#_b">/b</a></li>
		<li><a href="#_d">/d</a></li>
		<li><a href="#_p">/p</a></li>
		<li><a href="#_s">/s</a></li>
		<li><a href="#_incr">/incr</a></li>
		<li><a href="#_pickup">/pickup</a></li>
		<li><a href="#_drop">/drop</a></li>
		<li><a href="#_wire">/wire</a></li>
		<li><a href="#_unwire">/unwire</a></li>
		<li><a href="#_slider">/sl</a></li>
		<li><a href="#_copy">/copy</a></li>
		<li><a href="#_flip">/flip</a></li>
		<li><a href="#_turn">/turn</a></li>
		<li><a href="#_scale">/scale</a></li>
		<li><a href="#_factory">/factory</a></li>
		<li><a href="#_c">/c</a></li>
		</ul>
	</li>
	</ul>
</li>
</ul>

<h2>About Editing</h2>

<h3 id="game_state">Game State</h3>
Editing is changing state. There's a lot of it, but the interesting bits break down like so:
<ul>
	<li>
		Block state:
		<ul>
			<li><a href="#_p">position</a>, <a href="#_s">size</a>, velocity, <a href="#_c">color</a>, etc</li>
			<li><a href="#type">type</a> - represents the "logic" of blocks that "do things"</li>
			<li><a href="#material">material</a> - how it interacts when it hits another block</li>
			<li><a href="#_slider">sliders</a> - integers used to store internal state. Number and meaning is determined by the type.</li>
			<li><a href="#_wire">wires</a> - set of one-way connections to other blocks. Meaning is determined by the type.</li>
			<li><a href="#_pickup">holder</a> - blocks which are "connected" have a parent-child relationship, so a group of connected blocks will form a tree.</li>
		</ul>
	</li>
	<li>
		Player state:
		<ul>
			<li><a href="#_data">/data</a>, mostly used for team selection at the moment</li>
			<li><a href="#_c">color</a></li>
			<li>respawn counter</li>
		</ul>
	</li>
	<li>
		Misc:
		<ul>
			<li><a href="#_rule">gamerules</a> - grab bag of on/off flags</li>
			<li><a href="#_seed">random seed</a></li>
		</ul>
	</li>
</ul>
<br/><br/>
For the block state, it's worth noting that "type" and "material" are abstractions. Internally, these are some event handlers and flags.
While it's useful to mentally divide that information into "type" and "material", you'll see some commands that don't follow that distinction exactly.

<h3 id="edit_interface">Edit Interface</h3>
Editing is done from the normal game client. Edit commands are enabled by <a href="#_rule">gamerule</a> 10 (editing). You'll want the terminal from which you launched the game to be visible, as it is used extensively for information - and knowing is half the battle.
<br/><br/>
The editing interface breaks down into:
<ul>
	<li>Commands. There's a big section on these further down, they do everything. Press '<pre>/</pre>' (or '<pre>T</pre>') to start typing one.</li>
	<li>Keybinds. Some common commands have keybinds, these are listed with the command</li>
	<li>Player buffers / look direction. Some commands need inputs that it doesn't make sense to type. These deserve a bit more explanation...</li>
</ul>
<b id="buffers">Player Buffers</b><br/>
Player buffers are how you specify which blocks to operate on. You have 2 - Blue and Red. The basic buffer operations are tied to keyboard/mouse controls, and are enabled with <a href="#_edit">/edit</a> ("Edit Mode"). You'll want this on most of the time, but can turn it off to use "regular" controls - for testing, among other things.
Edit Mode doesn't affect your use of other editing commands.
<div class="para"></div>
Edit Mode controls are:
<ul>
	<li>LMB - Select a block. This is far easier to "aim" in first person (<pre>Tab</pre>). Whatever you click on, the corners will blink blue, and it will be added (or removed) in your Blue/Primary buffer.</li>
	<li>RMB - Like LMB, but operates on the Red/Secondary buffer.</li>
	<li>Shift + LMB (or RMB) - Clears the Blue (or Red) buffer.
	<li>Shift + Space - Swap Blue/Red buffers.</li>
</ul>
Once a block is in your buffer, you'll see a little blue (or red) indicator hovering around your player that points at the block. These indicators are, in fact, also blocks - but they don't collide, and in practice they don't get in your way.
<div id="empty_buffer" class="para"></div>
Note that if either buffer is empty, commands which use that buffer's contents will instead see one item - your player.
<br/><br/>
<b id="look_dir">Look Direction</b><br/>
Some commands need a direction as input. Typically these will use your Look Direction, which for the sake of editing is just whichever axis you are mostly looking down. For instance, your look direction can be <pre>+Z</pre> or <pre>-X</pre>.

<h2 id="commands">Commands</h2>
Commands are given in bold, followed by their arguments (if any) in regex syntax. The next lines will contain any keybinds, followed by a description of the command (including arguments, so you don't have to read regex).
<h3 id="buffer_manip">Buffer Manipulation</h3>
Commands to modify the <a href="#buffers">Player Buffers</a>. Often these will look at the Red buffer, do some logic, and select each result into the Blue buffer (or take it out, if it's already in the Blue buffer).
<br/><br/>
<b id="_inside">/inside</b> [0-3]?<br/>
<i>Ctrl+I - /inside 1</i><br/>
<i>Ctrl+Shift+I - /inside 2</i><br/>
Selects some items into (or out of) the Blue buffer based on the bounding box of the Red buffer.
<div class="para"></div>
Specifically, this first computes the bounding box for all blocks in the Red buffer, and chooses some blocks based on the command's argument (default 1):
<ul>
	<li>0 - blocks which touch the bounding box, even if they don't intersect it.</li>
	<li>1 - blocks which intersect the bounding box</li>
	<li>2 - blocks which are completely covered by the bounding box (may touch the boundary)</li>
	<li>3 - blocks which are completely surrounded by the bounding box (not touching the boundary)</li>
</ul>
The main use of this command is to select a bunch of blocks that are all in one place. Clear both buffers, select some blocks at the extremities (e.g. opposing corners) into the Red buffer, then issue <i>Ctrl+I</i>. Typically you'd then clear the Red buffer.
<br/><br/>
<b id="_wires">/wires</b><br/>
Usually you use this with an empty Blue buffer and one block in the Red buffer, which will select the blocks that the Red one is wired to.
<div class="para"></div>
More accurately, this starts with the block(s) in the Red buffer, grabs the blocks which any of those have a <a href="#_wire">wire</a> to, and selects <i>those</i> into (or out of) the Blue buffer.
<div class="para"></div>
Useful to check which wires a particular block has, or when "copying" the output wires on a block.
<br/><br/>
<b id="_held">/held</b><br/>
Selects into (or out of) the Blue buffer the blocks which are <a href="#_pickup">held</a> by any block in the Red buffer.
<br/><br/>
<b id="_tree">/tree</b><br/>
Selects into (or out of) the Blue buffer the contents of the Red buffer, and any blocks they're holding, recursively.
<br/><br/>
<h3 id="informational">Informational</h3>
These commands typically print some information to the terminal which launched the game.
<br/><br/>
<b id="_i">/i</b><br/>
The original info command. Prints information about the block in the Blue buffer; if there are more than one, I believe it takes the most recent?
<div class="para"></div>
Information printed includes the position, size, and color, as well as the values of any <a href="#_slider">sliders</a>. For some types (currently <a href="#_legg">/legg</a> / <a href="#_respawner">/respawner</a> / <a href="#_teamselect">/teamselect</a>), the slider output will be annotated with the meaning of each slider.
<div class="para"></div>
Finally, it prints the number of items in the Blue and Red buffers.
<br/><br/>
<b id="_m">/m</b><br/>
Measures the contents of the Blue buffer along the current <a href="#look_dir">Look Direction</a>, printing the measurements to the terminal. The reported "Outside" distance is the size of the Blue buffer's bounding box.
<div class="para"></div>
If there are exactly 2 items in the Blue buffer, this will also report a "Centers" distance (the distance between their centers) and an "Inside" distance (the empty space between the blocks, which will be negative if they are overlapping along that axis).
<br/><br/>
<b id="_hl">/hl</b><br/>
<i>Ctrl+F</i><br/>
Flips the colors of blocks in the Blue buffer. Intended as a visual aid to see what's selected. Issuing this command again will always restore the original color.
<div class="para"></div>
Clear items will be flipped to gray, though it is a special internal representation which will be flipped back to clear.
<br/><br/>
<h3 id="material">Material</h3>
These commands operate on the blocks in the Blue buffer, changing how their physics work. Applying a material command typically replaces the existing material, though some exceptions are noted.
<br/><br/>
<b id="_weight">/weight</b> [01]?<br/>
Weight controls whether a block is affected by gravity, and is not typically affected by other material commands. Weight is turned off, turned on, or toggled, if the argument is 0, 1, or absent, respectively.
<div class="para"></div>
Turning this off for your player can be useful to get to hard-to-reach places while editing.
<br/><br/>
<b id="_wall">/wall</b><br/>
Walls are the top-tier material, and are not pushed by anything. They also do not collide with other walls. To prevent walls from accidentally falling through the floor, this command will also turn off <a href="#_weight">/weight</a>.
<br/><br/>
<b id="_metal">/metal</b><br/>
Metal blocks are pushed by walls and other metal blocks.
<br/><br/>
<b id="_stone">/stone</b><br/>
Stone blocks are pushed by walls, metal, and other stone blocks.
<div class="para"></div>
Platforms spawned by players are stone.
<br/><br/>
<b id="_wood">/wood</b><br/>
Wood blocks are pushed by walls, metal, stone, and other wood blocks.
<div class="para"></div>
Wood blocks can also stack, unlike other materials.
<div class="para"></div>
Wood is approximately what players (and blocks spawned by players) are made of, though there is no material command for them exactly.
<br/><br/>
<b id="_paper">/paper</b><br/>
Paper blocks are pushed by everything.
<br/><br/>
<b id="_ghost">/ghost</b><br/>
Ghost blocks do not collide. This command will also turn off <a href="#_weight">/weight</a> so they don't fall straight through the floor, like that one episode of Batman Beyond that scarred me as a child.
<div class="para"></div>
Ghost blocks don't count against the collision checking at all (the most taxing part of the game logic). Also, they may be hard to select again; consider looking at the notes on <a href="#_inside">Ctrl+I</a>.
<br/><br/>
<b id="_decor">/decor</b><br/>
This is intended for use on blocks that are currently <a href="#_pickup">held</a>. It makes them <a href="#_ghost">/ghost</a> blocks, gives them <a href="#_weight">weight</a> (which won't matter so long as they are held), and adds a condition that they will turn into <a href="#_paper">/paper</a> if dropped.
<div class="para"></div>
This is intended to add decorative elements on vehicles or other complex objects, which will then turn into debris if the object is destroyed.
<br/><br/>
<b id="_friction">/friction</b> <span>number</span>?<br/>
Sets the friction on the blocks to the given number (or the default, 4, if no number is given). This value controls how much friction this block experiences when it is pushed by something else, <i>not</i> how much friction it applies to blocks that it pushes. Friction is not set by other material commands, and usually you won't need to set it either. It may be of use on <a href="#_legg">Leggs</a>, to give them more "grip".
<br/><br/>
<b id="_fpdraw">/fpdraw</b> [01]?<br/>
Controls whether certain parts of a vehicle are rendered in first person mode. Specifically, in first person mode, blocks with "/fpdraw 0" won't be rendered if they're part of the same <a href="#_tree">tree</a> as you. First-person drawing is turned off, turned on, or toggled, if the argument is 0, 1, or absent, respectively. This flag is not set by other material commands.
<div class="para"></div>
As a point of trivia, this is why you can't see your own eye in first-person mode.
<h3 id="type">Type</h3>
These commands change the special behaviors of the blocks in the Blue buffer. Typically this will replace any existing type, but some exceptions are noted.
<br/><br/>
<b id="_dumb">/dumb</b><br/>
Clears the type, the block is just a block.
<br/><br/>
<b id="_logic">/logic</b><br/>
Blocks of this type can send and process the signals used by things like <a href="#_respawner">/respawner</a> and <a href="#_factory">/factory</a> blocks. They can also act as sensors.
<div class="para"></div>
There are 2 logic signals, which we'll call "1" and "2". Logic blocks are active or not based on which signals they received last tick, and if active they send a signal(s) to every block they are <a href="#_wire">wired</a> to. Whether the block activates depends on its gate type, which is <a href="#_slider">slider</a> 0:
<ul>
	<li>0 - XOR - (received any "1") XOR (received any "2")</li>
	<li>1 - XNOR - (received any "1") XNOR (received any "2")</li>
	<li>2 - AND - (received any "1") AND (received any "2")</li>
</ul>
Which signal(s) the block sends when active is determined by slider 1, which should be in the range 0-3 (0 being "none" and 3 being "1"+"2").
<div class="para"></div>
Most non-logic blocks that concern themselves with signals (as mentioned in the first paragraph) just concern themselves with signal "1", and in some simple setups that's all you'll need. In such cases it may be helpful to think of XOR as a repeater and XNOR as an inverter.
<div class="para"></div>
Additionally, a logic block that pushes something (i.e. it's "heavier" than something that touched it) will receive a "1". This is why logic blocks can act as sensors. As an example, a simple logic block might have sliders set to (0, 1). This means it's an XOR gate, which broadcasts "1" when active. Every frame that something is pushing against it, it will broadcast a "1" to each of its wires.
<div class="para"></div>
You may also want to send a signal the <i>first</i> frame the block pushes something. This is fairly common, and you can <a href="#_import">import</a> <pre>itm/button.itm</pre> to handle this. It's just a collection of 3 logic blocks, set up to act as an edge detector. The small block on the side is the "output", which you should use to wire the button up to things or change its output signal(s). Both small blocks can be made <a href="#_c">invisible</a>+<a href="#_ghost">ghost</a> if you wish.
<div class="para"></div>
If you don't want sensor-like behavior on some logic block, tuck it away somewhere or make it a <a href="#_ghost">/ghost</a>.
<div class="para"></div>
There are many circuits that can be built from this behavior, but I'm not inclined to document them all here. However, one useful one is a toggle gate. If you have a gate that is going to be receiving (e.g.) "1" signals, and you would like it to toggle its output each time it does, you can set it to an XOR with "2" output, and add a wire to itself. This means the "2" channel will represent if it was on previously, and if a "1" signal comes in, the XOR behavior will flip that.
<br/><br/>
<b id="_logic_debug">/logic_debug</b><br/>
Exactly identical to <a href="#_logic">/logic</a>, but the block colors itself based on its gate type and whether or not it's active.
<div class="para"></div>
While this is mainly intended for visualizing logic systems while they are being built, it can also be used as a sort of indicator light.
<div class="para"></div>
Blocks can be changed freely between /logic and /logic_debug without losing configuration, since they have the same number of sliders.
<div class="para"></div>
Note that since these blocks re-set their color every tick, commands like <a href="#_c">/c</a> and <a href="#_hl">/hl</a> will not have a visible effect.
<br/><br/>
<b id="_rand">/rand</b><br/>
Similar to <a href="#_logic">/logic</a>, but only sends its signal(s) to one of its wired blocks (at random) when it is active. Blocks which received a "1" signal on the previous frame are ineligible for selection.
<br/><br/>
<b id="_delay">/delay</b><br/>
Blocks of this type are similar to a <a href="#_logic">/logic</a> XNOR, but they have a delay before they turn on. There is no delay to turn off, so it "prefers" to be off. The delay is set in <a href="#_slider">slider</a> 0. If this is set to 0, it will behave exactly like an XNOR.
<div class="para"></div>
As with regular /logic blocks, the output signals are controlled by slider 1.
<br/><br/>
<b id="_demolish">/demolish</b><br/>
Blocks of this type will destroy themselves when they receive a <a href="#_logic">logical</a> signal "1".
<br/><br/>
<b id="_gun">/gun</b><br/>
Makes the block a gun. Players can pick it up and shoot stuff. This one was easy to write about, if I don't get too far into specifics!
<br/><br/>
<b id="_door">/door</b><br/>
Makes the block travel between waypoints based on logic signals.
<div class="para"></div>
The block should be <a href="#_wire">/wire</a>d to some number of <a href="#_logic">/logic</a> blocks (waypoints). Its two sliders are, respectively, the top speed and acceleration it uses to get there. The target blocks should likely be <a href="#_ghost">/ghost</a> or part of the same <a href="#_tree">/tree</a> as the door, so they don't collide; the door will try to move its center to the waypoint's center.
<div class="para"></div>
The simplest setup is that exactly one of the waypoints should be active, and the door will travel there. More technically, the door will take the average velocity of all active waypoints as its frame of reference, and the average position of all active waypoints as its destination. If there are no active waypoints, it will try to come to rest, taking the average velocity of <i>all</i> waypoints as its frame of reference. If it is not wired to any blocks at all, it will be inert.
<div class="para"></div>
To get a typical "door" setup, you would have 2 (invisible, /ghost) logic gates, one in the doorway, and one in the wall. The wall gate is then wired to the doorway gate, which is an XNOR (inverter). This means the doorway gate will be active whenever the wall gate is inactive - you can then do whatever variety of circuitry you want to turn the wall gate on and off. See also <a href="#_logic">/logic</a>.
<br/><br/>
<b id="_teleport">/teleport</b><br/>
<b>/tp</b><br/>
Makes the block send anything that it touches to a <a href="_wire">wired</a> destination, if the /teleport block is able to push it (as per its <a href="material">material</a>). Things that instead push the /teleport block (like, say, the ground) will not be teleported.
<div class="para"></div>
The block can be wired to any number of destinations, which should be <a href="#_logic">/logic</a> blocks. At most one of these /logic blocks should be active. If none are active, nothing will happen; if more than one are active, for the moment it will print a message to the console and do nothing. In the future, multiple destinations may average their offsets, add their offsets, pick a random destination, or something else.
<div class="para"></div>
The position and velocity difference between the /teleport block and its chosen destination will be applied to the teleportee block. Note that the sizes of the blocks involved are not taken into consideration, only their centers.
<br/><br/>
<b id="_legg">/legg</b><br/>
Makes the block act as a leg, suitable for building walkers. The block should be <a href="#_pickup">held</a> by something, and should be <a href="#_wire">/wire</a>d to a <a href="#_seat">/seat</a>. There are several sliders which control the walk cycle; get more info on these by selecting one in-game and issueing <a href="#_i">/i</a>.
<div class="para"></div>
The overall idea is that the leg moves in a square pattern. On the bottom side of the square (when the leg is hopefully pushing the body forward), it will dip a little further down based on its speed (the "tread" depth). This helps make sure that if there are many legs, the one in contact with the ground is the one moving fastest.
<div class="para"></div>
Since a square has 4 sides, the total time for one walk cycle is the horizontal time plus the vertical time, doubled. With multiple leggs, you probably want them spaced evenly through that cycle. Again, check /i in-game for more.
<div class="para"></div>
Finally, consider setting a custom <a href="#_friction">/friction</a> on your leggs if they're slipping around too much.
<br/><br/>
<b id="_seat">/seat</b><br/>
Makes the block act as a control point for vehicles. Players connect on contact and can eject by jumping. Currently this is really only useful in conjunction with <a href="#_legg">/legg</a>s.
<div class="para"></div>
Most of the <a href="#_slider">slider</a>s are just used for representing the player's inputs, and are not worth documenting; however, the final 2 control the horizontal distance and elevation (respectively) of the third-person camera.
<br/><br/>
<b id="_respawner">/respawner</b><br/>
Makes the block respawn players. This is inhibited if the block is receiving a "1" <a href="#_logic">/logic</a> sigal. Note there is a <a href="#_rule">/rule</a> which respawns players as well, though the /rule version is older and just assigns team and location based on player index.
<div class="para"></div>
The exact meaning of the configuration <a href="#_slider">slider</a>s can be checked in-game with <a href="#_i">/i</a>, but the short version is that players are eligible for respawn at a given spawner based on their <a href="#_data">/data</a>, how long they've been dead, and how long since the spawner last spawned someone.
<div class="para"></div>
Currently there is the concept of "team", which is really only used by the blocks players shoot and may someday be removed completely. If spawned at a /respawner block, a players team will be based on whether their /data is even or odd.
<br/><br/>
<b id="_teamselect">/teamselect</b><br/>
Makes the block set the <a href="#_data">/data</a> and <a href="#_c">color</a> of players who touch it. The color is pulled from the block itself. The data is set to the value of <a href="#_slider">slider</a> 1, though only the bits selected by the mask (slider 0) are updated.
<br/><br/>
<b id="_scoreboard">/scoreboard</b><br/>
Makes the block keep score. The block can be anywhere on the level, and it will track team score (red vs blue) based on which team survives, and then reset the map. This command also sets the block's <a href="#material">material</a> to <a href="#_wall">/wall</a>.
<div class="para"></div>
More specifically, the block determines the team of each player by taking their <a href="#_data">/data</a> (modulus 4). The block will decide the round is over if any of the following conditions hold continuously for 5 seconds:
<ul>
	<li>All players are dead - tie</li>
	<li>All living players are team 1 - blue victory</li>
	<li>All living players are team 2 - red victory</li>
</ul>
It will then display the winner and the current score as a chat message.
<div class="para"></div>
After the round is scored, the map is reset. This can't be a full load, since player data and the current score should be kept, but it also can't be managed with <a href="#_factory">/factory</a> blocks since that would be a nightmare to maintain. Instead, the block will delete every other block in the world except for itself, then request whichever player is currently the <a href="#_loader">/loader</a> to <a href="#_add">/add</a> the most recently loaded map back into the world. The new scoreboard then emits a <a href="#_logic">logical</a> signal "1" to any wired blocks.
<div class="para"></div>
Mostly this approach results in a transparent experience. Some trickery with <a href="#material">materials</a> ensures that the newly-added instance of the scoreboard block destroys the existing one and copies its score. However, any quicksaves or quick-<a href="#_load">/load</a>s will likely result in unexpected behavior, and if the map data contains pre-placed players (as opposed to respawners) they won't be re-inhabited by the players when it resets. The signal which is emitted when the world resets can be (for instance) fed to an inverter and then to the <a href="#_respawner">respawners</a>, so that they are active for one frame when the world resets.
<br/><br/>
<b id="_cursed">/cursed</b><br/>
This does not completely overwrite the block's type, but it will be overwritten if another type is assigned. This just adds the behavior that if this block is ever <i>not</i> held by something, it will destroy itself.
<div class="para"></div>
This is typically useful for immaterial things (perhaps <a href="#_logic">/logic</a> gates or <a href="#_respawner">/respawner</a>s) that are attached to a larger object, which you don't want to be left as orphans if the larger object is destroyed.
<h3 id="misc">Miscellaneous</h3>
I could try to come up with more categories, but honestly it feels a little forced past this point. Here's the rest of the commands.
<br/><br/>
<b id="_save">/save</b> <span>path</span>?<br/>
<i>Ctrl+Q: /save</i><br/>
Writes the game state to disk. This is more or less the complete state, down to the current random seed and the <a href="#_data">/data</a> of any players. Without an argument, the path defaults to "savegame", so <i>Ctrl+Q</i> effectively serves as a quicksave. When providing the path, any relative path will work; typically I'll use the <pre>.sav</pre> or <pre>.gam</pre> extension, but I should probably pick one...
<div class="para"></div>
All file I/O happens in the <pre>data/</pre> directory.
<br/><br/>
<b id="_load">/load</b> <span>path</span>?<br/>
<i>Ctrl+L: /load</i><br/>
Reads the game state from disk, broadcasting it to all players. If the file has more players than are currently in-game, the extra player data is discarded; if it has fewer, the leftover players are reset (as though they had freshly connected). As with <a href="#_save">/save</a>, the default path if none is provided is "savegame".
<div class="para"></div>
All file I/O happens in the <pre>data/</pre> directory.
<br/><br/>
<b id="_loader">/loader</b> [01]?<br/>
Shouldn't be needed normally. Reads/writes your loader status.
<div class="para"></div>
Whoever issued <a href="_load">/load</a> most recently is automatically set as the loader. In cases where game logic requires someone to read from disk, the loader will process this.
<br/><br/>
<b id="_file">/file</b> <span>path</span>?<br/>
Shouldn't be needed normally. Reads/writes the loaded filename.
<div class="para"></div>
This is set automatically when you issue <a href="_load">/load</a> (see also <a href="_loader">/loader</a>). If the game logic wants to reload the game, and you are the loader, this path will be used.
<br/><br/>
<b id="_sync">/sync</b><br/>
<i>Ctrl+R</i><br/>
Sends the current game state over the network (similar to <a href="#_load">/load</a>). Hopefully this isn't needed except for when new players join, as the clients should stay in sync. When a new player connects, existing players will see a message prompting them to press <i>Ctrl+R</i>, so the new player is brought up to speed. This could probably be automated but it's more of a hassle than you'd think to do it well, so I haven't done it.
<br/><br/>
<b id="_export">/export</b> <span>path</span><br/>
Similar to <a href="#_save">/save</a>, but only applies to the contents of the Blue buffer. Positions and velocities are saved relative to the player, rather than in world coordinates. Typically these paths use the <pre>.itm</pre> suffix, and may be placed in the <pre>itm/</pre> folder. Useful if you've created something you want to reuse.
<div class="para"></div>
All file I/O happens in the <pre>data/</pre> directory.
<br/><br/>
<b id="_import">/import</b> <span>path</span><br/>
Imports something that was previously <a href="#_export">/export</a>ed, relative to the player. The new blocks will be added to the Blue buffer.
<br/><br/>
<b id="_add">/add</b> <span>number</span>{6} <span>path</span><br/>
Similar to <a href="#_import">/import</a>, but is relative to the absolute position and velocity vectors supplied before the path. Does not add the blocks to the Blue buffer. Maybe think of a better name?
<div class="para"></div>
Currently the plan is for the operation underlying this command to be used by game logic in some cases, so it does not require <a href="#_rule">/rule</a> 10 to be on.
<br/><br/>
<b id="_data">/data</b> <span>number</span>?<br/>
Sets the player's data, or prints the existing data to the terminal if no argument is given. Currently this is really just used for <a href="#_respawner">/respawner</a>s, and in practice you probably only need 0, 1, or 2. 
<br/><br/>
<b id="_edit">/edit</b><br/>
<i>Ctrl+Tab</i><br/>
Turns edit mode on or off for the player. If on, the player controls are used for basic <a href="#buffers">buffer manipulation</a>, and a special crosshairs is used. Note that this is reset if you respawn.
<br/><br/>
<b id="_rule">/rule</b> <span>number</span>?<br/>
Without an argument, prints the names and descriptions of the various game rules. With an argument, toggles the specified rule on or off.
<div class="para"></div>
A full listing is best found in-game, but these are things like world boundaries, gravity, default player respawning (see <a href="#_respawner">/respawner</a>), and enabling edit commands.
<br/><br/>
<b id="_seed">/seed</b> <span>number</span>?<br/>
Sets (for one argument) or displays (for no arguments) the current RNG seed.
<br/><br/>
<b id="_reseed">/reseed</b><br/>
Resets the current RNG seed based on the time. Note that a <a href="#_load">/load</a> of a game restores the state exactly as it was, including the seed, so /reseed can be helpful if you want "random" events to play out differently.
<br/><br/>
<b id="_b">/b</b> <span>number</span>{3}<br/>
<i>Ctrl+B: /b 400 400 400</i><br/>
Creates a white <a href="#_wall">/wall</a> block directly above the player, which is added to the Blue <a href="#buffers">buffer</a>.
<br/><br/>
<b id="_d">/d</b><br/>
Deletes all blocks in the Blue <a href="#buffers">buffer</a>.
<br/><br/>
<b id="_p">/p</b> <span>number</span>{0,3}<br/>
<i>Ctrl+E</i><br/>
<i>Ctrl+MouseWheel</i><br/>
<i>Ctrl+Click+Drag</i><br/>
<div class="para"></div>
For "push", or "position". This acts differently based on the number of arguments, but always moves the contents of the Blue buffer by some offset (maintaining their relative positions).
<ul>
	<li>For 3 arguments, moves the block(s) to that absolute position. Specifically, the center of the Blue bounding box will be moved there.</li>
	<li>For 2 arguments, expects an axis (0-2) and an amount to move along that axis. This form mostly exists for the mouse binds (<i>Ctrl+MouseWheel</i>, <i>Ctrl+Click+Drag</i>), which use the current <a href="#_incr">/incr</a> as the amount.</li>
	<li>For 1 argument, moves the block(s) along the <a href="#look_dir">Look Direction</a> by that amount.</li>
	<li>
		For no arguments (<i>Ctrl+E</i>), moves the block(s) along the <a href="#look_dir">Look Direction</a> until the next time a Blue buffer block aligns with a Red buffer block. If there are no further alignment opportunities, nothing is moved.
		<div class="para"></div>
		In this context, two blocks "align" on a given axis when either their centers have the same coordinate on that axis, or they are both flush with the same plane perpendicular to that axis (either on opposites sides of the plane, or on the same side). 
	</li>
</ul>
The zero-argument version (<i>Ctrl+E</i>) can be useful with an empty Red buffer (to pull the Blue buffer to you). You can also hold it down with both buffers empty to move quickly along an axis (by repeatedly aligning yourself with yourself, effectively offsetting yourself by your own width). Especially useful when <a href="#_weight">weightless</a>.
<br/><br/>
<b id="_s">/s</b> <span>number</span>{1,3}<br/>
<i>Alt+Shift?+MouseWheel</i><br/>
<i>Alt+Shift?+Click+Drag</i><br/>
<div class="para"></div>
For "size", or "stretch". Adjusts the size of the blocks in the Blue buffer, though the exact behavior depends on the number of arguments. All dimensions supplied to this command should be even.
<ul>
	<li>For 3 arguments, sets the block's dimensions to the given numbers.</li>
	<li>
		For 2 arguments, expects a face (between -3 and 2) and an amount to stretch that face. This form mostly exists for the mouse binds (<i>Alt+MouseWheel</i>, <i>Alt+Click+Drag</i>), which use the current <a href="#_incr">/incr</a> as the amount. <i>Shift</i> will cause the mouse binds to shrink instead of stretch. The faces (in order) are -Z, -Y, -X, X, Y, Z. I don't expect you to remember that, I expect you to use the mouse binds.
	</li>
	<li>
		For 1 argument, stretches the face opposite the <a href="#look_dir">Look Direction</a> (i.e. the face you're "looking at") by the given amount (positive numbers will increase the size).
	</li>
</ul>
<br/><br/>
<b id="_incr">/incr</b> <span>number</span>?<br/>
For commands that have mouse keybinds (<a href="#_p">/p</a> and <a href="#_s">/s</a>), sets (for 1 argument) or displays (for 0 arguments) the number used for those keybinds. Default is 200.
<br/><br/>
<b id="_pickup">/pickup</b> [012]?<br/>
Causes the blocks in the Blue buffer to be held by the block in the Red buffer (Red buffer should contain one block). Blocks can be held by some other block, or not at all, resulting in a tree structure. Blocks that are held do not experience gravity, and blocks that are part of the same tree will not collide with each other. If a block that is holding blocks gets pushed, that impulse will be copied to all of its children (so they move as a unit). If a block that is being held gets pushed, its behavior is determined by the argument which was provided to /pickup (default 0):
<ul>
	<li>0 - The impulse is passed up to the parent block, which may face the same choice if it is also held. If this mode is used all the way up the tree, then the whole tree will be moved as one unit when the child block is pushed.</li>
	<li>1 - The child block will detach if it is pushed.</li>
	<li>2 - The child block will process the impulse without forwarding it to the parent block. Under "normal" conditions this will be strange behavior, as a gentle tap will send the child block drifting further and further from its parent (blocks can be held without touching, or even being close). However, it may be desired e.g. if the child is a <a href="#_door">/door</a>.
</ul>
<br/><br/>
<b id="_drop">/drop</b><br/>
Blocks in the Blue buffer will be dropped if they are currently <a href="#_pickup">held</a>.
<br/><br/>
<b id="_wire">/wire</b><br/>
Each block in the Red buffer gains a wire to each block in the Blue buffer, if it doesn't already have one.
<div class="para"></div>
Wires are one-way references that blocks may have to other blocks. They form a set, meaning you can't wire to the same block twice, and the order of wires doesn't matter (ideally). The meaning/effect of wires is determined by whatever the block's <a href="#type">type</a> chooses to do with them; they will have no effect at all on a "dumb" block.
<div class="para"></div>
It may seem the buffers should be flipped here, but I would argue it's better this way. The Red-parent/Blue-child setup mirrors <a href="#_pickup">/pickup</a>'s behavior, as well as that of the closely-related <a href="#_wires">/wires</a> command.
<br/><br/>
<b id="_unwire">/unwire</b><br/>
Removes any <a href="#_wire">wires</a> on Red buffer blocks that point to Blue buffer blocks.
<br/><br/>
<b id="_slider">/sl</b> <span>number</span> <span>number</span></br>
<i>Short for /slider</i><br/>
Sets the slider specified by the first number (zero-indexed) to the value of the second number. Sliders are the numbers that blocks use for internal state, and the number and meaning of the sliders on a block is determined by its <a href="#type">type</a>.
<br/><br/>
<b id="_copy">/copy</b><br/>
Makes a copy of the blocks in the Blue buffer. Relationships between blocks (<a href="#_wire">wires</a>, and being <a href="#_pickup">held</a>) will be copied if both of the blocks are copied.
<div class="para"></div>
The copied blocks will be placed adjacent to the original blocks, opposite the <a href="#look_dir">Look Direction</a> (roughly "towards you", if you're looking at it). Afterwards, the Red buffer will contain the original blocks, and the Blue buffer will contain the new blocks.
<br/><br/>
<b id="_flip">/flip</b><br/>
Flips the contents of the Blue buffer on the axis indicated by the <a href="#look_dir">Look Direction</a>. The center of the Blue bounding box will be maintained. This only affects positions, not velocities or anything more complex (e.g. <a href="#_legg">leggs</a> won't flip their sense of "up" and "down").
<br/><br/>
<b id="_turn">/turn</b><br/>
Similar to <a href="#_flip">/flip</a>, but does a 1/4 turn. Positions and sizes are affected. The direction and axis of the turn are determined by your <a href="#look_dir">Look Direction</a>, such that if you were looking at the blocks along that axis you would see them turn clockwise 90&deg;.
<div class="para"></div>
For example, assume you have a model car you want to make a right-hand turn. This would look clockwise from above, so you'd look down and issue <pre>/turn</pre>.
<div class="para"></div>
As a technical note, if the bounding box's width has different even/odd parity along the two axes that are being turned between, it will be impossible to precisely maintain the bounding box's center. A message will be printed to this effect.
<br/><br/>
<b id="_scale">/scale</b> <span>number</span> <span>number</span><br/>
Scales the contents of the Blue buffer up or down (affecting positions and sizes). The scale factor will be the ratio of the first argument to the second; for instance, scaling up by 50% can be achieved with <pre>/scale 3 2</pre>. Note that the center of the bounding box will be (approximately) maintained; if you're scaling up something resting on the ground, you may want to raise it first (possibly while <a href="#_weight">weight</a>-less).
<div class="para"></div>
If the scaling cannot be done exactly (e.g. <pre>/scale 4 3</pre> with a size or displacement that isn't divisible by 3), a warning will be printed instead. You can perform the (approximate) scaling anyway by using the <pre>/scale!</pre> command, which is otherwise the same.
<br/><br/>
<b id="_factory">/factory</b><br/>
Transforms the blocks in the Blue buffer into factory blocks instead. These can be used to generate a copy of the original blocks on-demand, though internally the mechanism is entirely different from <a href="#_copy">/copy</a>. To activate the factory, a <a href="#_logic">logic</a> pulse should be delivered to each factory block on the same frame (e.g. by <a href="#_wire">/wire</a>-ing one logic gate to all of them).
<div class="para"></div>
In terms of how they produce their product, factory blocks should mostly be treated as a black box. There's nothing terribly arcane, but there are a lot of sliders required to replicate all the state, and restoring wires does require additional factory blocks (which are automatically added to the Blue buffer, so you don't need to worry about that). It is almost always easier to instantiate the factory, make some change on the object, and turn that back into a new factory, than it is to modify an existing factory.
<div class="para"></div>
However, so long as you don't mess with <a href="#_slider">sliders</a> or <a href="#type">types</a>, most other operations are fine. For example, you can move, <a href="#_copy">/copy</a>, <a href="#_flip">/flip</a>, and re-<a href="#_c">color</a> factories freely, or even <a href="#_pickup">attach</a> them to something. Most <a href="#material">material commands</a> are also fine, e.g. <a href="#_wall">/wall</a> for ease of manipulation, but you'll probably want it back as a <a href="#_ghost">/ghost</a> before activating it.
<br/><br/>
<b id="_c">/c</b> ([0-9A-F]{6}|<span>CSS4_name</span>)<br/>
Colors the blocks in the Blue buffer. Colors can be in a few formats, but the most sensible ones are 6-digit hex or a CSS4 color name (like 'lightgray'). It also recognizes the color 'clear', which is transparent.
<div class="para"></div>
This command also works even with the editing <a href="#_rule">/rule</a> disabled, in which case it always just affects your player (both your current block, and future spawns).
</body>
</html>
