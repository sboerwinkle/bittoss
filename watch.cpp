// Based on code generated by ChatGPT.

#include <errno.h>
#include <limits.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/inotify.h>
#include <unistd.h>

#include "main.h"

#define BUF_LEN (sizeof(struct inotify_event) + NAME_MAX + 1)
// According to ChatGPT, this alignment stuff is a performance benefit on x86 architectures.
// On other architectures, it may be *mandatory*, as misaligned accesses are much worse there.
// This really isn't performance-critical code, and I doubt the rest of this project is
// portable to other architectures anyway.
// However, I'm still leaving it in for now since it's neat and I learned something.
static char buf[BUF_LEN] __attribute__((aligned(__alignof__(struct inotify_event))));

int watch_fd;

void watch_read() {
	ssize_t len = read(watch_fd, buf, sizeof(buf));

	if (len == -1) {
		if (errno == EINTR) {
			// We know there's something to read here, but it's still possible we get
			// EINTR from some signal. For now we just leave and let our `poll` loop
			// call us again.
			return;
		}
		// Other error, something's up??
		perror("watch read");
		return;
	}

	struct inotify_event *ev;
	for (
		char *ptr = buf;
		ptr < buf + len;
		ptr += sizeof(struct inotify_event) + ev->len
	) {
		ev = (struct inotify_event *)ptr;

		if (
			(ev->mask & IN_CLOSE_WRITE)
			&& ev->len > 0
			&& !strcmp(ev->name, "srm.so")
		) {
			dl_srm_ready = 1;
		}
	}
}

void watch_init() {
	watch_fd = inotify_init();
	if (watch_fd == -1) {
		perror("inotify_init");
		exit(1);
	}

	// For now just watching one dir, we could always do more
	// (or maybe just put all the stuff we want to write in one watchable dir...
	int wd = inotify_add_watch(watch_fd, "../dl_srm", IN_CLOSE_WRITE);
	if (wd == -1) {
		perror("inotify_add_watch");
		close(watch_fd);
		exit(1);
	}

	// For now we discard `wd`, but we might want it if we watch more stuff.
}

void watch_destroy() {
	if (close(watch_fd)) {
		perror("watch close");
	}
}
